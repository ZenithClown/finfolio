/********************************************************************
DBML - Database Markup Language for ERD & Documentation

DBML is an unique language developed by the Holistics Software INC.
(https://www.holistics.io/) designed to define and document database
structures and schema (https://dbml.dbdiagram.io/home).

The project schema and usages are described under the `project` tag
which supports markdown syntax when the document is hosted using
https://dbdocs.io/ website.
********************************************************************/

project finfolio {
  database_type: 'PostgreSQL'
  document_name: 'Finace Portfolio Schema'

  note: '''
    The schema is designed for **personal financial analysis** (for \
    self and other family members) that gives a quick glimpse on the \
    earnings and expenditure. The design is kept as simple as \
    possible, however it is recommended that people with a coding \
    background to use the same.

    More Information: https://github.com/ZenithClown/finfolio

    ## ERD Documentation Guide

    A single file approach is adopted for easier management, \
    documentation and understanding the schema layout. While any \
    type of database can be used to store the data, PostgreSQL is \
    used as the de-facto database by myself.

    The project is designed with a "privacy first" approach, and no \
    data is stored in a cloud server and is not shared with any \
    third-party applications. It is upto the end user to maintain \
    security of the database. Any platform that supports PostgreSQL \
    database architecture like FireBase, by Google INC. or Aurora DB \
    by Amazon Web Services, or SupaBase (FOSS), etc. can be used.

    [DB Diagram](https://dbdiagram.io/) is used for documenting, and \
    hosting the docs using the [DBML](https://dbml.dbdiagram.io/home) \
    for visibility. The following notations are adopted.

    ### SQL Name Notations

    Typically, there is no standard (or universal) notation guide \
    when it comes to SQL language, however the following must be \
    maintained to keep a uniformity:

      *  Object names should be easily understood,
      * Table and column names are not pluraized, and are `snake_case`,
      * Abbreviations should be self explanatory and should be kept \
        uniform throught the database,
      * Some prefixes are used for constraint names for \
        better understanding and readbility:
        - `pk_` : prefix for constraint name that are primary key,
        - `fk_` : prefix for constraint name that are foreign key,
        - `uq_` : prefix for constraint name that is unque.
      * Tables are optionally given a suffix to understand the type \
        of table:
        - `_mw` or `_master` : master table name suffix,
        - `_vw` : view table name suffix,
        - `_trx` : transactional table name suffix.
      * Other database elements like functions, stored procedures are \
        optionally suffixed as below:
        - `_usp` : user defined stored procedures,
        - `_udf` : user defined functions,

    ### Schema Defination

    The database is seperated into the following schema for control \
    and seperating different workloads:

    #### METADATA (`meta`) Schema Namespace

    A special schema namespace to hold configuration and related \
    information that is being used in the database for various \
    reporting.

    #### PRIVATE (`private`) Schema Namespace

    A schema to hold private informations like user transactions, and \
    any other personal information. Typically, if on a self-hosted or \
    in a managed cloud this schema needs to be provided the maximum \
    security by the end user.

    #### PUBLIC (`public`) Schema Namespace

    The PostgreSQL default schema `public` is used to store user \
    typical information like name, email, account details etc. While \
    the name of the schema suggests `public` but security should be \
    maintained as many personal information may otherwise be exposed.

    #### Other Extended Schema

    Some other extended features are also available for analysis and \
    is available as an extension pack. The schema are as below:

      * `stocks` - if a user wish to track stock market transactions \
        like mutual funds, shares, etc. then this extension is useful.

    ## Data Security & BI

    The data security is left at the discretion of the end-user. \
    Note that the tool is developed for personal finance management \
    and a person with the knowledge of database and related tools \
    used are required to handle the same.

    Typically, if an user uses secured client-server database like \
    MySQL or PostgreSQL then the same may suffice in terms of \
    security.
  '''
}

/********************************************************************
  // ! METADATA Schema Table(s)

Simple master data table, to maintain simplicity the table uses a
single monolithic approach (removed normalization) as static data and
does not change over time.
********************************************************************/

table meta.account_type_master {
  account_type_key varchar(7) [pk]

  // account primary type - this field are must required for reference
  account_type_id char(3) [not null]

  account_type_name varchar(32)  [not null]
  account_type_desc varchar(128) [not null]

  // account subtype details, added for further classification
  account_subtype_id char(3)

  account_subtype_name varchar(34)
  account_subtype_desc varchar(64)
}

table meta.expense_category_master {
  expense_category_key  varchar(65) [pk]

  expense_category_name varchar(16) [not null]
  expense_category_desc varchar(72) [not null]

  // expense sub category integration into one table
  expense_subcategory_name varchar(48)
  expense_subcategory_desc varchar(96)
}

table meta.income_category_master {
  income_category_key varchar(65) [pk]

  income_category_name varchar(16) [not null]
  income_category_desc varchar(72) [not null]

  // income sub category integration into one table
  income_subcategory_name varchar(48)
  income_subcategory_desc varchar(96)
}

/********************************************************************
  // ! PUBLIC Schema Table(s)
********************************************************************/

table public.user_account_detail {
  username varchar(16) [pk]
  fullname varchar(64) [unique, not null]

  // good to have features, but not required to be maintained
  email varchar(128) [unique]
  phone varchar(16)  [unique]

  // date of birth is crucial for certain calculations/projections
  date_of_birth date

  // ..versionchanged:: d747086d28cfb562936618fd6df7f7df91d10b44
  // get user role from custom enum data type, this is present in db
  user_role meta.user_role [not null, default: "USER"]

  // patch for 5695350108a29424d2f6b5660c57c85dc836f29a
  managed_by varchar(16) [ref: > public.user_account_detail.username]

  // patch for a100a43a21fd57ce20056690a81efae9484e1a37
  password text [not null]

  note: '''
    Table Schema for an User Account

    The user account is the starting point for the personal \
    finance management application, where, the head of the \
    family may add more members account details.

    A model scope is under development to provide row level security \
    based on a user role. A super administrator (`sudo` or `admin`) \
    has all the access follows by others as in a *nix based system.
  '''
}

table public.ledger_account_detail {
  // ? using randomly generated keys for account id
  // however, other end user may change the same as per need
  ledger_account_id char(5) [pk]

  // the following information is for identification by end user
  account_name  varchar(64) [unique, not null]
  account_owner varchar(16) [not null, ref: > public.user_account_detail.username]

  // the type of account has a significant impact on end calculation
  // a single account key is used to identify the type of account and calculation
  account_type_key char(3) [not null, ref: > meta.account_type_master.account_type_key]

  // ? account opening and closing information for future reference
  account_opened_on date [not null]
  account_closed_on date

  // an account may also be set as inactive even if the account is not closed
  account_marked_inactive_on date

  // ? we may not have all the transactions, thus we can set an opening balance
  opening_balance             numeric(12, 2) [not null, default: 0.00]
  opening_balance_recorded_on date           [not null] // default `account_opened_on`
}

/********************************************************************
  // ! PRIVATE Schema Table(s)
********************************************************************/

table private.user_transaction {
  // ? primary table containing all the transactions for all tracked accounts
  transaction_idkey bigint [pk]

  account_id char(5) [not null, ref: > public.ledger_account_detail.ledger_account_id]

  // trx:: transaction short hand, created to reduce column name
  // all the below columns are important and is fetched/kept as available from the passbook
  trx_date   date                  [not null]
  trx_type   meta.transaction_type [not null]
  trx_desc   varchar(512)          [not null]
  trx_amount numeric(12, 2)        [not null]

  // additional fields which can either be auto populated by ai/ml or maybe updated manually by the user
  transfer_method meta.transaction_method

  // categorization of income based on different categories and sub-categories
  income_category_key varchar(16) [ref: > meta.income_category_master.income_category_key]

  // categorization of transactions based on different categories and sub categories
  expense_category_key varchar(16) [ref: > meta.expense_category_master.expense_category_key]

  // self account id, check 5e08526ef2cc89cb4acf5252a2520515d47bcc9d
  self_account_id char(5) [ref: > public.ledger_account_detail.ledger_account_id]

  // ? utility field for developer purpose and have no other usage
  created_on timestamp [not null, default: 'timezone(utc, now())']
  updated_at timestamp
}

/********************************************************************
  // ! Extended Schema - Stocks Master Table(s)
********************************************************************/

table stocks.assets_master {
  isin_code char(12) [pk]

  // each stock has an assocuated name, which can be duplicate
  // always reference stocks, mutual funds, etc. usiing isin code
  asset_name  varchar(128)       [not null]
  asset_class stocks.asset_class [not null]
}

table stocks.asset_symbol_master {
  hexdigest char(64) [pk] // this will be sript generated
  isin_code char(12) [not null, ref: > stocks.assets_master.isin_code]

  // register any or required stock exchanges for tracking as enum type
  stock_exchange stocks.stock_exchange [not null]

  // a same stock/mutual fund/symbol may have different name based
  // on a different exchange, store data as rows; typically naster
  stock_symbol varchar(32) [not null]
}

table stocks.historic_public_offering {
  isin_code char(12) [pk, ref: > stocks.assets_master.isin_code]

  // this can be useful to check the luck factor in an ipo and also
  // how the ipo has performed before and after, and the total profit
  // make from the ipo/ofs/etc. if allotted or bought with a strategy
  opening_date date [not null]
  closing_date date [not null]
  listing_date date [not null]

  // a typical share has a floor and a ceiling price, if only one
  // value is present then insert the same value twice in the fields
  floor_price   numeric(12, 2) [not null]
  ceiling_price numeric(12, 2) [not null]

  // ipo/ofs issue amount, this value is currently under development
  issue_amount_in_cr numeric(12, 2)

  // public offering type can be any of the defined type in an enum
  po_type stocks.public_offering_type [not null]
}

/********************************************************************
  // ! Extended Schema - Stocks Transaction Table(s)
********************************************************************/

table stocks.user_transaction {
  // ? primary table containing all the transactions for all tracked accounts
  transaction_idkey bigint [pk]

  account_id char(5) [not null, ref: > public.ledger_account_detail.ledger_account_id]

  // all the below columns are important and is fetched/kept as available from the passbook
  trade_date     date                  [not null]
  isin_code      char(12)              [not null, ref: > stocks.assets_master.isin_code]
  exchange_name  stocks.stock_exchange [not null]
  trade_type     stocks.trade_type     [not null]
  trade_quantity numeric(12, 2)        [not null]
  trade_price    numeric(12, 2)        [not null]

  // ? utility field for developer purpose and have no other usage
  created_on timestamp [not null, default: 'timezone(utc, now())']
  updated_at timestamp

  // check special flag enum type for more details
  trade_special_flag stocks.trade_special_flag
}
